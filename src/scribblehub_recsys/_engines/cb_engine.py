import re

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.preprocessing import MultiLabelBinarizer, RobustScaler, MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack

class CBRecommender():

    def __init__(self, novels_df):
        self.novels_df = novels_df
        

    def _clean_data(self, string_list):
        """Convert list of strings to lower-case and remove spaces between words.
        """
        
        if isinstance(string_list, list):
            return [str.lower(i.replace(' ', '')) for i in string_list]
        else:
            if isinstance(string_list, str):
                return str.lower(string_list.replace(' ', ''))
            else:
                return ''
        
    def _create_soup(self, df):
        """Createas a string-soup from columns in the novels dataframe.

        Args:
            df (DataFrame): Novels DataFrame with the columns 'tags', 'author', and 'fandom_tags'

        Returns:
            string: Concatenated 'soup' string of all tags, fandom_tags and author. 
        """
        
        return ' '.join(df['tags']) + ' ' + ' ' + str(df['author']) + ' ' + ' '.join(df['fandom_tags'])

    def recommend(self, novel_id, N, matrix, indices, novels_df):
        """Generate a recommendation.

        Args:
            novel_id (int): The novel ID used a basis for getting the recommendation.
            matrix (kernel matrix): ndarray of shape (n_samples_X, n_samples_Y).
            indexes (Pandas Series): A Pandas Series object which have the index and the Novel ID.

        Returns:
            DataFrame: List of recommendations.
        """
        N += 1 # Number 1 is always the novel itself.
        idx = indices[novel_id]
        matrix_scores = list(enumerate(matrix[idx]))
        matrix_scores = sorted(matrix_scores, key=lambda x: x[1], reverse=True)
        matrix_scores = matrix_scores[1:N]
        novel_indices = [i[0] for i in matrix_scores]
        
        return novels_df[['novel_id', 'title', 'author', 'weighted_rating', 'chapters', 'synopsis']].iloc[novel_indices]


    def ranking(self, df):
        """Print out the the top 20 rankings based on the IMDB's rating formula.

        Args:
            df (DataFrame): Novels DataFrame which has the columns 'rating' and 'rating_votes'
        """
        df = df.sort_values('weighted_rating', ascending=False)
        
        print(df[['novel_id', 'title', 'rating_votes', 'weighted_rating']].head(20))

    # TODO Figure out how to evaluate a CB Engine?
    def evaluate_engine(self):
        """Not implemented.
        
        Evaluate the recommendations generated by the engine.
        
        Returns:
            None: None
        """
        raise NotImplementedError
    
    
    def _generate_mlb_matrix(self, novels_df):
        """MLB is good for limited categorical data, such as Genres.
        
        """
        mlb = MultiLabelBinarizer()
        return mlb.fit_transform(novels_df['genres'])# + novels_df['tags'])
    
    
    def _generate_cv_matrix(self, novels_df):
        """CV is useful for the tags and author. 
        This will count each occurence of a word and convert it into a matrix.
        
        """
        
        count = CountVectorizer(stop_words='english')
        return count.fit_transform(novels_df['soup'])
    
    def _clean_synopsis(self, df):
        synopsis = ''.join(df)
        synopsis = re.sub(r'<.*?>', '', synopsis) # remove html tags
        synopsis = re.sub(r'[^\w\s]', '', synopsis) # remove punctuation and special characters
        synopsis = re.sub(r'\n', '', synopsis) # remove line breaks
        synopsis = re.sub(r'\s+', ' ', synopsis) # collapse multiple whitespaces into a single space
        return synopsis.lower() # convert to lowercase and split into words
    
    def _generate_tfv_matrix(self, novels_df):
        """TD-IDF is the go-to-algorithm for analyzing raw text data. 
        It takes the inverse domain frequency and converts it into a matrix.
        
        """
        
        tfv = TfidfVectorizer(min_df=3, 
                            max_features=None,
                            strip_accents='unicode', analyzer='word', 
                            token_pattern=r'\w{1,}',
                            ngram_range=(1,3),
                            stop_words='english')

        novels_df['synopsis'] = novels_df['synopsis'].fillna('')
        novels_df['synopsis'] = novels_df['synopsis'].apply(self._clean_synopsis)
        return tfv.fit_transform(novels_df['synopsis'])
    
    
    def _generate_numeric_data(self, novels_df):        
        """Lastly we have the numerical data, such as ratings, readers, 
        chapters, etc. Here we normalize and scale it so it fits in a 0-1 range.
        
        """
        
        ratings = novels_df['weighted_rating'].values
        chapters = novels_df['chapters'].values
        readers = novels_df['readers'].values
        favorites = novels_df['favorites'].values
        views = novels_df['total_views_all'].values
        
        #Remove outliers that negatively impact the cb-system.
        rb = RobustScaler()
        chapters = rb.fit_transform(chapters.reshape(-1, 1))
        readers = rb.fit_transform(readers.reshape(-1, 1))
        favorites = rb.fit_transform(favorites.reshape(-1, 1))
        views = rb.fit_transform(views.reshape(-1, 1))
        
        mm = MinMaxScaler(feature_range=(0,1))
        ratings = mm.fit_transform(ratings.reshape(-1, 1))
        chapters = mm.fit_transform(chapters)
        readers = mm.fit_transform(readers)
        favorites = mm.fit_transform(favorites)
        views = mm.fit_transform(views)
        
        return {"weighted_rating": ratings, "chapters": chapters, "readers": readers, "favorites": favorites, "views": views}
    
    def fit(self, novels_df):
        """Fit the CBRecommender with the data provided

        """
        
        """Convert the JSON formatted tags, genres, fandom_tags into a list of strings."""
        features = ['tags', 'genres', 'fandom_tags']
        for feature in features:
            novels_df[feature] = novels_df[feature].apply(self._clean_data)

        novels_df['soup'] = novels_df.apply(self._create_soup, axis=1)
        
        mlb_matrix = self._generate_mlb_matrix(novels_df)
        cv_matrix = self._generate_cv_matrix(novels_df)
        tfv_matrix = self._generate_tfv_matrix(novels_df)
        numeric_data = self._generate_numeric_data(novels_df)
        

        # We stack the different matrixes from MLB, 
        # CV, TD-IDF, etc. into a collected 'feature_matrix'."""
        feature_matrix = hstack([mlb_matrix, cv_matrix, tfv_matrix, 
                                 numeric_data["weighted_rating"], numeric_data["chapters"], 
                                 numeric_data["readers"], numeric_data["favorites"], 
                                 numeric_data["views"]])
        
        # Calculate the cosine similarity between the different vectors 
        # in the feature_matrix. We use cosine_similarity because it is magnitude insensitive."""
        similarity_matrix = cosine_similarity(feature_matrix, feature_matrix)
        
        indices = pd.Series(novels_df.index, index=novels_df['novel_id']).drop_duplicates()
        return similarity_matrix, indices

  
